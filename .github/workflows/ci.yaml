# .github/workflows/ci.yaml
name: ci

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build and push'
        required: true
        default: 'Test-Branch' # Default to your test branch

# env:
  # REGISTRY: ghcr.io # Removed - Using Docker Hub now

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - dockerfile: ./dockerfile
            context: .
            image: sparshbajaj14/f1-dash-live
            target: live
          - dockerfile: ./dockerfile
            context: .
            image: sparshbajaj14/f1-dash-api
            target: api
          - dockerfile: ./dash/dockerfile
            context: ./dash
            image: sparshbajaj14/f1-dash
            args: |
              ENABLE_TRACKING="true"
              LIVE_SOCKET_URL="http://localhost:4000"
              API_URL="http://localhost:4001"

    permissions:
      contents: read
      # packages: write # Removed - Not needed for Docker Hub
      attestations: write # Still needed for generating provenance with build-push-action
      id-token: write # Still needed if using keyless signing or OIDC features

    steps:
      # --- ADDED DEBUG STEP ---
      - name: Debug Context Before Checkout
        run: |
          echo ">>>>> DEBUGGING START <<<<<"
          echo "Event Name: ${{ github.event_name }}"
          echo "Input Branch (from workflow_dispatch): '${{ github.event.inputs.branch }}'" # Added quotes for clarity
          echo "GitHub Ref (for push events): ${{ github.ref }}"
          echo "Resolved Ref for Checkout: '${{ github.event_name == 'workflow_dispatch' && github.event.inputs.branch || github.ref }}'" # Added quotes
          echo ">>>>> DEBUGGING END <<<<<"
      # --- END OF ADDED DEBUG STEP ---

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use the branch from the manual trigger input if the event is workflow_dispatch
          # Otherwise, use the default ref (e.g., refs/heads/main) for push events
          ref: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.branch || github.ref }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3 # Optional: Good practice for multi-platform builds if needed later

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3 # Use v3 for consistency

      - name: Login to Docker Hub
        uses: docker/login-action@v3 # Use v3 for consistency
        with:
          # registry: # Omit for Docker Hub (it's the default)
          username: sparshbajaj14 # Using your provided username
          password: ${{ secrets.DOCKERHUB_TOKEN }} # Make sure this secret is set in GitHub repo settings

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5 # Use v5 for consistency
        with:
          images: ${{ matrix.image }}
          tags: |
            type=ref,event=branch # e.g., main, develop, Test-Branch
            type=sha,prefix= # Git SHA as tag
            type=raw,value=latest,enable={{is_default_branch}} # 'latest' tag for default branch (usually main)

      - name: Build, push, and attest Docker image
        id: push
        uses: docker/build-push-action@v6 # Use v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          target: ${{ matrix.target }}
          build-args: ${{ matrix.args }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha # Enable GitHub Actions cache for build layers
          cache-to: type=gha,mode=max
          # Generate SLSA provenance attestations using the build action itself
          attests: |
            type=provenance

      # Optional: Signing steps remain the same
      - name: Sign the published Docker image
        if: startsWith(github.ref, 'refs/tags/v') # Example: Only sign tagged releases
        uses: docker/metadata-action@v5
        id: sign_meta
        with:
          images: ${{ matrix.image }}
          tags: |
            type=ref,event=tag # Get the specific tag being pushed

      - name: Sign the published Docker image with Cosign
        if: startsWith(github.ref, 'refs/tags/v') && steps.sign_meta.outputs.tags != '' # Ensure tag exists
        # This step requires Cosign installation and configuration (keys, etc.)
        # Example using keyless signing (requires id-token: write permission)
        run: |
          echo "Signing image: ${{ steps.sign_meta.outputs.tags }}"
          # Add Cosign installation here if not using a pre-built image/action
          # cosign sign --yes "${{ steps.sign_meta.outputs.tags }}"
          echo "Note: Cosign signing step is a placeholder. Implement actual signing logic."
        # Example using a dedicated action:
        # uses: sigstore/cosign-installer@v3
        # uses: sigstore/cosign-action@v3
        # with:
        #   images: ${{ steps.sign_meta.outputs.tags }}
        #   # Add other cosign options like keys/kms

      # The separate attestation step is intentionally left out/commented out
      # - name: Generate artifact attestation
      #   uses: actions/attest-build-provenance@v1
      #   # ... (removed)